{"version":3,"sources":["../public/sw.js"],"names":["NetworkFirst","CacheFirst","StaleWhileRevalidate","registerRoute","precacheAndRoute","event","updateWidget","updateName","widgetDefinition","payload","name","url","request","data","fullPath"],"mappings":"AAAA,cACE,yEACF,EAEA,GAAI,QAAS,CACX,QAAQ,IAAI,8BAA8B,EAC1C,QAAQ,IAAI,gBAAiB,QAAQ,IAAI,EAEzC,QAAQ,KAAK,gBAEb,KAAM,CAAE,aAAA,EAAc,WAAA,EAAY,qBAAA,CAAoB,EAAK,QAAQ,WAC7D,CAAE,cAAA,GAAkB,QAAQ,QAC5B,CAAE,iBAAA,GAAqB,QAAQ,WAMrC,KAAK,iBAAiB,gBAAkB,GAAU,CAChD,EAAM,UAAU,EAAa,CAAK,CAAC,CACvC,CAAG,EAGD,KAAK,iBAAiB,eAAiB,GAAU,CAC/C,EAAM,UAAU,EAAa,CAAK,CAAC,CACvC,CAAG,EAID,KAAK,iBAAiB,cAAgB,GAAU,CAC1C,EAAM,QAAU,cAClB,EAAM,UAAU,EAAW,CAAK,CAAC,CAEvC,CAAG,EAID,KAAK,iBAAiB,kBAAoB,GAAU,CAAA,CAAG,EAEvD,MAAM,EAAe,MAAO,GAAU,CAEpC,MAAM,EAAmB,EAAM,OAAO,WAGhC,EAAU,CACd,SAAU,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,YAAY,GAAG,MAAM,EAClF,KAAM,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,IAAI,GAAG,MAAM,CAC5E,EAGI,MAAM,KAAK,QAAQ,mBAAmB,EAAM,WAAY,CAAO,CACnE,EAEQ,EAAa,MAAO,GAAU,CAClC,MAAM,EAAO,EAAM,KAAK,KAAI,EAAG,KAGzB,EAAmB,EAAM,OAAO,WAGhC,EAAU,CACd,SAAU,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,YAAY,GAAG,MAAM,EAClF,KAAM,KAAK,UAAU,CAAE,KAAA,CAAI,CAAE,CACnC,EAGI,MAAM,KAAK,QAAQ,mBAAmB,EAAM,WAAY,CAAO,CACnE,EAME,EACE,CAAC,CAAE,IAAA,CAAG,IAAO,EAAI,SAAS,WAAW,gBAAgB,GAAK,EAAI,KAAK,SAAS,kEAAkE,EAC9I,IAAI,EAAW,CACb,UAAW,gBACX,QAAS,CACP,IAAI,QAAQ,kBAAkB,wBAAwB,CACpD,SAAU,CAAC,EAAG,GAAG,CAC3B,CAAS,EACD,IAAI,QAAQ,WAAW,iBAAiB,CACtC,cAAe,GAAK,GAAK,GAAK,GAC9B,WAAY,EACtB,CAAS,CACT,CACA,CAAK,CACL,EAGE,EACE,CAAC,CAAE,IAAA,CAAG,IAAO,EAAI,SAAS,WAAW,OAAO,EAC5C,IAAI,CACR,EAGE,EACE,CAAC,CAAE,IAAA,CAAG,IAAO,EAAI,SAAS,WAAW,SAAS,EAC9C,IAAI,CACR,EAGE,EACE,CAAC,CAAE,QAAA,CAAO,IACR,EAAQ,cAAgB,UACxB,EAAQ,cAAgB,SACxB,EAAQ,cAAgB,SAC1B,IAAI,CACR,EAGE,EACE,CAAC,CAAE,QAAA,CAAO,IAAO,EAAQ,OAAS,WAClC,IAAI,CACR,EAEE,KAAK,iBAAiB,OAAQ,SAAU,EAAO,CAE7C,GADA,QAAQ,IAAI,iCAAiC,EACzC,aAAa,aAAe,UAAW,CACzC,MAAM,EAAO,EAAM,KAAK,KAAI,EAC5B,EAAM,UACJ,KAAK,aAAa,iBAAiB,EAAK,MAAO,CAC7C,KAAM,EAAK,KACX,KAAM,6BACN,IAAK,QACf,CAAS,CACT,CACA,MACM,QAAQ,IAAI,yCAAyC,CAE3D,CAAG,EAED,KAAK,iBAAiB,oBAAsB,GAAU,CACpD,EAAM,aAAa,MAAK,EACxB,IAAI,EAAW,KAAK,SAAS,OAAS,EAAM,aAAa,KAAK,KAC9D,QAAQ,WAAW,CAAQ,CAC/B,CAAG,EAGD,KAAK,iBAAiB,UAAY,GAAU,CACtC,EAAM,MAAQ,EAAM,KAAK,OAAS,iBACpC,QAAQ,IAAI,gDAAgD,EAC5D,KAAK,YAAW,EAEtB,CAAG,EAED,KAAK,iBAAiB,UAAY,GAAU,CAC1C,QAAQ,IAAI,0BAA2B,CAAK,CAChD,CAAG,EAED,EAAiB,osHAAK,eAAiB,CAAA,CAAE,CAE3C,MACE,QAAQ,MAAM,kCAAkC","file":"sw.js","sourcesContent":["importScripts(\n  'https://storage.googleapis.com/workbox-cdn/releases/7.3.0/workbox-sw.js'\n);\n\nif (workbox) {\n  console.log('Workbox loaded successfully!');\n  console.log('workbox.core:', workbox.core); // Add this line\n\n  workbox.core.initializeApp(); // Access initializeApp through the global workbox object\n\n  const { NetworkFirst, CacheFirst, StaleWhileRevalidate } = workbox.strategies;\n  const { registerRoute } = workbox.routing;\n  const { precacheAndRoute } = workbox.precaching;\n\n  // This is your Service Worker, you can put any of your custom Service Worker\n  // code in this file, above the `precacheAndRoute` line.\n\n  // When widget is installed/pinned, push initial state.\n  self.addEventListener('widgetinstall', (event) => {\n    event.waitUntil(updateWidget(event));\n  });\n\n  // When widget is shown, update content to ensure it is up-to-date.\n  self.addEventListener('widgetresume', (event) => {\n    event.waitUntil(updateWidget(event));\n  });\n\n  // When the user clicks an element with an associated Action.Execute,\n  // handle according to the 'verb' in event.action.\n  self.addEventListener('widgetclick', (event) => {\n    if (event.action == \"updateName\") {\n      event.waitUntil(updateName(event));\n    }\n  });\n\n  // When the widget is uninstalled/unpinned, clean up any unnecessary\n  // periodic sync or widget-related state.\n  self.addEventListener('widgetuninstall', (event) => { });\n\n  const updateWidget = async (event) => {\n    // The widget definition represents the fields specified in the manifest.\n    const widgetDefinition = event.widget.definition;\n\n    // Fetch the template and data defined in the manifest to generate the payload.\n    const payload = {\n      template: JSON.stringify(await (await fetch(widgetDefinition.msAcTemplate)).json()),\n      data: JSON.stringify(await (await fetch(widgetDefinition.data)).json()),\n    };\n\n    // Push payload to widget.\n    await self.widgets.updateByInstanceId(event.instanceId, payload);\n  }\n\n  const updateName = async (event) => {\n    const name = event.data.json().name;\n\n    // The widget definition represents the fields specified in the manifest.\n    const widgetDefinition = event.widget.definition;\n\n    // Fetch the template and data defined in the manifest to generate the payload.\n    const payload = {\n      template: JSON.stringify(await (await fetch(widgetDefinition.msAcTemplate)).json()),\n      data: JSON.stringify({ name }),\n    };\n\n    // Push payload to widget.\n    await self.widgets.updateByInstanceId(event.instanceId, payload);\n  }\n\n  // Workbox Precaching\n  // precacheAndRoute(self.__WB_MANIFEST || []);\n\n  // Assuming your sl-icon icons are served from a specific path, e.g., '/assets/icons/' or a CDN\n  registerRoute(\n    ({ url }) => url.pathname.startsWith('/assets/icons/') || url.host.includes('https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2'), // Adjust the URL pattern\n    new CacheFirst({\n      cacheName: 'sl-icon-cache',\n      plugins: [\n        new workbox.cacheableResponse.CacheableResponsePlugin({\n          statuses: [0, 200], // Cache successful responses and opaque responses (for cross-origin)\n        }),\n        new workbox.expiration.ExpirationPlugin({\n          maxAgeSeconds: 30 * 24 * 60 * 60, // Cache for 30 days (adjust as needed)\n          maxEntries: 50, // Keep a maximum of 50 icon files (adjust as needed)\n        }),\n      ],\n    })\n  );\n\n  // Cache data\n  registerRoute(\n    ({ url }) => url.pathname.startsWith('/data'),\n    new CacheFirst()\n  );\n\n  // Cache app images\n  registerRoute(\n    ({ url }) => url.pathname.startsWith('/assets'),\n    new CacheFirst()\n  );\n\n  // Cache app CSS and JS files\n  registerRoute(\n    ({ request }) =>\n      request.destination === 'script' ||\n      request.destination === 'style' ||\n      request.destination === 'module', // Cache dynamically imported modules\n    new StaleWhileRevalidate()\n  );\n\n  // Navigation Routing\n  registerRoute(\n    ({ request }) => request.mode === 'navigate',\n    new NetworkFirst()\n  );\n\n  self.addEventListener('push', function (event) {\n    console.log('[Service Worker] Push Received.');\n    if (Notification.permission === \"granted\") {\n      const data = event.data.json();\n      event.waitUntil(\n        self.registration.showNotification(data.title, {\n          body: data.body,\n          icon: '/assets/icons/icon_192.png', // Replace with your icon\n          tag: 'my-tag' // Optional: prevents multiple notifications with the same tag\n        })\n      );\n    } else {\n      console.log(\"Notification permission has been denied\");\n    }\n  });\n\n  self.addEventListener('notificationclick', (event) => {\n    event.notification.close();\n    var fullPath = self.location.origin + event.notification.data.path;\n    clients.openWindow(fullPath);\n  });\n\n  // Update notification events\n  self.addEventListener('message', (event) => {\n    if (event.data && event.data.type === 'SKIP_WAITING') {\n      console.log(\"Skip waiting was called in the service worker.\");\n      self.skipWaiting();\n    }\n  });\n\n  self.addEventListener(\"install\", (event) => {\n    console.log(\"Service Worker install:\", event)\n  });\n\n  precacheAndRoute(self.__WB_MANIFEST || []); // Ensure your manifest also includes icon files if they are part of your build\n\n} else {\n  console.error('Workbox failed to load from CDN.');\n}\n"]}