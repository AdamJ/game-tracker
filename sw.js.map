{"version":3,"sources":["../public/sw.js"],"names":["event","updateWidget","updateName","widgetDefinition","payload","name","url","request","data","fullPath"],"mappings":"AAAA,cACE,yEACF,EAMA,KAAK,iBAAiB,gBAAkB,GAAU,CAChD,EAAM,UAAU,EAAa,CAAK,CAAC,CACrC,CAAC,EAGD,KAAK,iBAAiB,eAAiB,GAAU,CAC/C,EAAM,UAAU,EAAa,CAAK,CAAC,CACrC,CAAC,EAID,KAAK,iBAAiB,cAAgB,GAAU,CAC1C,EAAM,QAAU,cAClB,EAAM,UAAU,EAAW,CAAK,CAAC,CAErC,CAAC,EAID,KAAK,iBAAiB,kBAAoB,GAAU,CAAA,CAAG,EAEvD,MAAM,EAAe,MAAO,GAAU,CAEpC,MAAM,EAAmB,EAAM,OAAO,WAGhC,EAAU,CACd,SAAU,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,YAAY,GAAG,MAAM,EAClF,KAAM,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,IAAI,GAAG,MAAM,CACvE,EAGD,MAAM,KAAK,QAAQ,mBAAmB,EAAM,WAAY,CAAO,CACjE,EAEM,EAAa,MAAO,GAAU,CAClC,MAAM,EAAO,EAAM,KAAK,KAAM,EAAC,KAGzB,EAAmB,EAAM,OAAO,WAGhC,EAAU,CACd,SAAU,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,YAAY,GAAG,MAAM,EAClF,KAAM,KAAK,UAAU,CAAE,KAAA,CAAI,CAAE,CAC9B,EAGD,MAAM,KAAK,QAAQ,mBAAmB,EAAM,WAAY,CAAO,CACjE,EAGA,QAAQ,WAAW,iBAAiB,osHAAK,eAAiB,CAAA,CAAE,EAG5D,QAAQ,QAAQ,cACd,CAAC,CAAC,IAAA,CAAG,IAAM,EAAI,SAAS,WAAW,OAAO,EAC1C,IAAI,QAAQ,WAAW,UACzB,EAEA,QAAQ,QAAQ,cACd,CAAC,CAAC,IAAA,CAAG,IAAM,EAAI,SAAS,WAAW,SAAS,EAC5C,IAAI,QAAQ,WAAW,UACzB,EAGA,QAAQ,QAAQ,cACd,CAAC,CAAC,QAAA,CAAO,IAAM,EAAQ,cAAgB,UACvC,EAAQ,cAAgB,SACxB,EAAQ,cAAgB,SACxB,IAAI,QAAQ,WAAW,oBACzB,EAIA,QAAQ,QAAQ,cACd,CAAC,CAAE,QAAA,CAAO,IAAO,EAAQ,OAAS,WAClC,QAAQ,WAAW,aAAY,CACjC,EAEA,KAAK,iBAAiB,OAAQ,SAAU,EAAO,CAE7C,GADA,QAAQ,IAAI,iCAAiC,EACzC,aAAa,aAAe,UAAW,CACzC,MAAM,EAAO,EAAM,KAAK,KAAM,EAC9B,EAAM,UACJ,KAAK,aAAa,iBAAiB,EAAK,MAAO,CAC7C,KAAM,EAAK,KACX,KAAM,6BACN,IAAK,QACN,CAAA,CACF,CACL,MACI,QAAQ,IAAI,yCAAyC,CAEzD,CAAC,EAED,KAAK,iBAAiB,oBAAsB,GAAU,CACpD,EAAM,aAAa,MAAO,EAC1B,IAAI,EAAW,KAAK,SAAS,OAAS,EAAM,aAAa,KAAK,KAC9D,QAAQ,WAAW,CAAQ,CAC7B,CAAC,EAGD,KAAK,iBAAiB,UAAY,GAAU,CACtC,EAAM,MAAQ,EAAM,KAAK,OAAS,iBACpC,QAAQ,IAAI,gDAAgD,EAC5D,KAAK,YAAa,EAEtB,CAAC,EAED,KAAK,iBAAiB,UAAY,GAAU,CAC1C,QAAQ,IAAI,0BAA2B,CAAK,CAC9C,CAAC","file":"sw.js","sourcesContent":["importScripts(\n  'https://storage.googleapis.com/workbox-cdn/releases/7.3.0/workbox-sw.js'\n);\n\n// This is your Service Worker, you can put any of your custom Service Worker\n// code in this file, above the `precacheAndRoute` line.\n\n// When widget is installed/pinned, push initial state.\nself.addEventListener('widgetinstall', (event) => {\n  event.waitUntil(updateWidget(event));\n});\n\n// When widget is shown, update content to ensure it is up-to-date.\nself.addEventListener('widgetresume', (event) => {\n  event.waitUntil(updateWidget(event));\n});\n\n// When the user clicks an element with an associated Action.Execute,\n// handle according to the 'verb' in event.action.\nself.addEventListener('widgetclick', (event) => {\n  if (event.action == \"updateName\") {\n    event.waitUntil(updateName(event));\n  }\n});\n\n// When the widget is uninstalled/unpinned, clean up any unnecessary\n// periodic sync or widget-related state.\nself.addEventListener('widgetuninstall', (event) => { });\n\nconst updateWidget = async (event) => {\n  // The widget definition represents the fields specified in the manifest.\n  const widgetDefinition = event.widget.definition;\n\n  // Fetch the template and data defined in the manifest to generate the payload.\n  const payload = {\n    template: JSON.stringify(await (await fetch(widgetDefinition.msAcTemplate)).json()),\n    data: JSON.stringify(await (await fetch(widgetDefinition.data)).json()),\n  };\n\n  // Push payload to widget.\n  await self.widgets.updateByInstanceId(event.instanceId, payload);\n}\n\nconst updateName = async (event) => {\n  const name = event.data.json().name;\n\n  // The widget definition represents the fields specified in the manifest.\n  const widgetDefinition = event.widget.definition;\n\n  // Fetch the template and data defined in the manifest to generate the payload.\n  const payload = {\n    template: JSON.stringify(await (await fetch(widgetDefinition.msAcTemplate)).json()),\n    data: JSON.stringify({ name }),\n  };\n\n  // Push payload to widget.\n  await self.widgets.updateByInstanceId(event.instanceId, payload);\n}\n\n// Workbox Precaching\nworkbox.precaching.precacheAndRoute(self.__WB_MANIFEST || []);\n\n// Cache data\nworkbox.routing.registerRoute(\n  ({url}) => url.pathname.startsWith('/data'),\n  new workbox.strategies.CacheFirst()\n);\n// Cache app images\nworkbox.routing.registerRoute(\n  ({url}) => url.pathname.startsWith('/assets'),\n  new workbox.strategies.CacheFirst()\n);\n\n// Cache app CSS and JS files\nworkbox.routing.registerRoute(\n  ({request}) => request.destination === 'script' ||\n  request.destination === 'style' ||\n  request.destination === 'module', // Cache dynamically imported modules\n  new workbox.strategies.StaleWhileRevalidate()\n);\n\n\n// Navigation Routing\nworkbox.routing.registerRoute(\n  ({ request }) => request.mode === 'navigate',\n  workbox.strategies.networkFirst()\n);\n\nself.addEventListener('push', function (event) {\n  console.log('[Service Worker] Push Received.');\n  if (Notification.permission === \"granted\") {\n    const data = event.data.json();\n    event.waitUntil(\n      self.registration.showNotification(data.title, {\n        body: data.body,\n        icon: '/assets/icons/icon_192.png', // Replace with your icon\n        tag: 'my-tag' // Optional: prevents multiple notifications with the same tag\n      })\n    );\n  } else {\n    console.log(\"Notification permission has been denied\");\n  }\n});\n\nself.addEventListener('notificationclick', (event) => {\n  event.notification.close();\n  var fullPath = self.location.origin + event.notification.data.path;\n  clients.openWindow(fullPath);\n});\n\n// Update notification events\nself.addEventListener('message', (event) => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    console.log(\"Skip waiting was called in the service worker.\");\n    self.skipWaiting();\n  }\n});\n\nself.addEventListener(\"install\", (event) => {\n  console.log(\"Service Worker install:\", event)\n});\n"]}